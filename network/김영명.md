# Network

---

# OSI 7 계층


![img.png](images/ymk/OSI7_ymk.png)

---

> **OSI 7**
> 
> **_국제표준화기구(ISO)에서 개발한 모델로서, 네트워크 프로토콜 디자인과 통신 과정을 7개의 계층으로 구분하여
> 만든 표준 규격이다._** 

- **_Application Layer (응용 계층)_**
  - **최종 목적지로 응용 프로그램과 연관하여 서비스를 수행하는 계층**
  - 사용자와 직접 접하는 유일한 계층.
  - EX) HTTP, DNS, FTP...


- **_Presentation Layer (표현 계층)_**
  - **데이터 압축, 변환이 이뤄지는 계층** 
  - 응용 계층으로부터 전달 받거나 전송하는 데이터의 인코딩 - 디코딩 및 암호화 등이 이루어지는 계층.
  - 코드 간의 번역을 담당하여 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어준다.
  - EX) JPEG, MPEG, AFP


- **_Session Layer (세션 계층)_**
  - **데이터가 통신하기 위한 논리적 연결을 담당하는 계층**
  - 통신 세션을 구성하는 계층으로, 포트 (Port) 번호를 기반으로 연결한다.
  - TCP/IP 세션을 만들고 없애는 역할
  - 통신하는 사용자들을 동기화하고 오류 복구 명령들을 일괄적으로 다룬다.
  - 네트워크 상 양쪽 연결을 관리하고 연결을 지속시켜주는 계층
  - _Session_ -> 클라이언트와 웹 서버 간 네트워크 연결이 지속적으로 유지되고 있는 상태


- **_Transport Layer (전송 계층)_**
  - **종단 간의 사용자들에게 신뢰성 있는 데이터를 전달하는 계층**
  - 패킷의 전송이 유효한지 확인하고, 전송에 실패된 패킷을 다시 보내는 것과 같은 신뢰성 있는 통신을 보장한다.
  - 흐름 제어: 송신측과 수신측 사이의 데이터 처리 속도 차이를 제어
  - 혼잡 제어: 네트워크 혼잡을 피하기 위해 데이터의 전송 속도 제어
  - 오류 제어: 오류 검출과 재전송


- **_Network Layer (네트워크 계층)_**
  - **IP를 지정하고 라우터로 경로를 선택해 네트워크를 통해 패킷을 전달하는 계층**
  - 전송되는 데이커는 패킷 단위로 분할하여 전송한 후 다시 합쳐진다.


- **_DataLink Layer (데이터 링크 계층)_**
  - **신뢰성 있는 전송을 보장하기 위한 계층**
  - 물리적인 네트워크 사이에 데이터 전송을 담당하는 계층
  - MAC(맥) 주소를 가지고 통신
  - 패킷을 프레임(Frame)으로 구성하여 물리 계층으로 전송
  - 묶여있는 호스트-노드 또는 노드-노드 사이에서의 신뢰성 관련 기능을 제공한다.


- **_Physical Layer (물리 계층)_**
  - **전기적, 물리적 세부 사항을 정의하는 계층**
  - 단지 데이터를 전달만 할 뿐, 전송받으려는 데이터가 무엇인지, 어떤 에러가 있는지는 전혀 신경 쓰지 않는다.
  - 상위 계층(데이터 링크)에서 전송된 데이터를 물리적인 전송 매체(허브, 라우터, 케이블 등)를 통해  다른 시스템에
    전기적 신호를 전송하는 역할

## 전송 계층

> **전송 계층과 데이터 링크 계층의 차이?**
> 
> 전송 계층은 논리적으로 1:1 연결된 송신, 수신 호스트 즉 종단간의 호스트에 관한 신뢰성 관련 기능을 제공하고,
> 데이터 링크 계층은 물리적으로ㅓ 1:1 연결된 호스트 사이의 전송 즉 직접 묶여있는 호스트-노드 또는 노드-노드 사이에서의 
> 신뢰성 관련 기능을 제공한다.

* **_TCP 패킷 추적 관리_**
  * 데이터는 패킷 단위로 쪼개져 같은 목적지로 전송된다.
  * 따라서 패킷에 각각 번호를 부여하여 패킷의 분실 확인 처리를 하기 위해 목적지에서 패킷을 재조립한다.


* **_흐름 제어_**
  * 송신측과 수신측 사이의 데이터 처리 차이를 제어하기 위한 기법으로 송신측의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지한다.
  * 슬라이딩 윈도우를 사용한다.
    * 송신 측에서 0,1,2,3,4,5,6을 보낼 수 있는 프레임을 가지고 있고 0,1을 전송했다면 슬라이딩 윈도우 구조는 2,3,4,5,6으로 변한다.
    * 수신측에서 ACK를 보내게 되면 송신측은 이전에 보낸 데이터 0,1을 수신측에서 정상적으로 받았음을 알게 되고 ACK 개수 만큼 프레임의 수를 
    오른쪽으로 확장한다.


* **_오류 제어_**
  * 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류를 복구한다.
  * 이때 2가지 방식이 있다.
    * Stop and Wait ARQ
      * 수신측에서 ACK 또는 NAK를 보낸다.
      * 수신측에서 받지 못하는 경우 NAK를 보내고 송신측은 해당 데이터를 재전송한다.
      * 만약 분실된 경우 일정한 간격의 시간을 두고 타임 아웃이 되면 송신측에서 재전송한다.
    * Go-Back-n ARQ
      * 손상되거나 분실된 경우 확인된 마지막 프레임 이후로 모든 프레임을 재전송한다.
      * 예를 들어 수신측에서 1, 3을 받게 되면 3을 버리고 2를 받지 못했다고 송신측에 보내고 송신측은 2부터 데이터를 다시 보낸다.
    * SR ARQ
      * Go-Back-n을 보완한 방법으로 손실된 프레임만 재전송한다.
      * 별도의 데이터 재정렬을 수행해야 하며, 별도의 버퍼를 필요로 한다.


* **_혼잡 제어_**
  * 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것
  * AIMD 방식
    * 처음 패킷 하나를 보내 문제가 없다면 Window Size를 1씩 증가시키는 방식
    * 문제가 발생하면 Window Size를 절반으로 줄인다.
    * 초기에 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리고 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다.
  * Slow Start 방식
    * 패킷을 2배씩 증가하여 데이터의 크기가 지수함수적으로 증가한다.
    * 전송되는 데이터의 크기가 임계값에 도달하면 혼잡 회피 단계로 넘어간다.
    * 혼잡 현상이 발생하면 Window size를 1로 줄인다.
    * 혼잡 현상이 발생했던 Window Size 절반 까지는 지수함수 꼴로 증가하고 이후부터는 1씩 증가한다.
  * Fast recovery 빠른 회복 방식
    * 혼잡 시 1로 줄이지 않고 절반으로 줄이고 선형 증가
  * 혼잡 회피
    * 임계값을 넘어가면 Window Size 1씩만 선형적으로 증가


---

# TCP/IP 4 계층

> **_TCP/IP란?_**
>
> TCP/IP는 IP(인터넷 프로토콜)와 TCP(전송 조절 프로토콜)의 묶음을 의미한다. 즉 두가지 프로토콜 방식을 조합하여 인터넷 통신하는 것을 TCP/IP 라고 부른다.
> 송신자가 수신자에게 IP를 사용하여 최대한 빠르게 패킷을 전송하면 TCP를 활용해 패킷을 정상적으로 수신 받는다.
> 이렇게 복수의 프로토콜 집합을 프로토콜 스택, 또는 프로토콜 스위트라고 부르며, 서로 다른 프로토콜 스택끼리는 통신할 수 없다.

* **IP (Internet Protocol)**
  * IP는 패킷 데이터들을 최대한 빨리 특정 목적지 주소로 보내는 프로토콜이다.
  * 빨리 보내는 것이 목적이기 때문에 패킷 전달 여부는 보증하지 않고 패킷을 보낸 순서와 받는 순서가 다를 수 있다.


* **TCP (Transmission Control Protocol)**
  * 패킷 통신은 작은 단위로 나누어 전송하기 때문에, 순서가 뒤섞이거나 내용이 유실될 수 있다는 단점이 있다.
  * 이러한 문제를 해결하기 위해 TCP 라는 프로토콜이 존재한다.
  * TCP는 패킷을 정상적으로 받을 수 있도록 하는 프로토콜이다.
  * 패킷 전달 여부를 보증하고, 패킷을 송신 순서대로 받게 해준다.
  * 즉, 목적지에 도착한 패킷들을 순서대로 정렬하고, 손상되거나 손실된 패킷이 있다면, 출발지에 재요청하는 방식으로 진행한다.


![img.png](images/ymk/TCPIP4_ymk.png)


* 실제 사용되는 TCP/IP는 OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 모형이다
  * 네트워크 전송 시 데이터 표준을 정리한 것이 OSI 7계층, 이 이론을 실제 사용하는 인터넷 표준이 TCP/IP 4계층이다.

---

# DNS

> **_DNS(Domain Name System)란?_**
> 
> 웹사이트에 접속 할 때 우리는 외우기 어려운 IP 주소 대신 도메인 이름을 사용한다. 도메인 이름을 사용했을 때 입력한 도메인을 실제 네트워크상에서 사용하는 IP 주소로 바꾸고 해당 IP 주소로 접속하는 과정이 필요하다.
> 이러한 과정, 전체 시스템을 DNS(도메인 네임 시스템)라고 한다. 상위 기관에서 인증된 기관에게 도메인을 생성하거나 IP 주소로 변경할 수 있는 ‘권한’을 부여한다.
> DNS는 이처럼 상위 기관과 하위 기관과 같은 ‘계층 구조’를 가지는 분산 데이터베이스 구조를 가진다.

### DNS 구성 요소

1.도메인 네임 스페이스 (Domain Name Space): 규칙 또는 방법으로 도메인 이름 저장을 분산한다.

2.네임 서버(Name Server) = 권한 있는 DNS 서버: 해당 도메인 이름의 IP 주소를 찾는다.

3.리졸버(Resolver) = 권한 없는 DNS 서버: DNS 클라이언트 요청을 네임 서버로 전달하고 찾은 정보를 클라이언트에게 제공하는 기능을 수행한다.

리졸버는 한 단말에 구현할 수 없기 때문에 보통은 리졸버가 구현된 네임 서버의 IP 주소만을 파악한다. 이러한 네임 서버는 대표적으로
SK, KT, LG와 같은 ISP(통신사) DNS가 있다. 즉 Resolver = Recursive DNS Server = Local Server = Recursor.

### 도메인 네임 스페이스(Domain Name Space)
![img.png](images/ymk/DomainNameSpace_ymk.png)

### 네임 서버(Name Server, DNS Server)

1. Root DNS 서버
* 국제 인터넷 주소 관리 기구(ICANN)에서는 루트 영역에 있는 13개 IP 주소 중 하나에 대한 서버를 운영하고 나머지 12개 IP 주소의 운영을 NASA, 메릴랜드 대학교, 그리고 루트 IP 주소 중 두 개를 운영하는 유일한 조직인 Verisign을 포함한 다양한 조직에 위임한다.
* TLD DNS 서버 IP 주소를 저장하고 안내하는 역할을 한다.

2. Top-Level Domain(TLD) DNS 서버
* 도메인 등록 기관이 관리하는 서버.
* SLD DNS 서버의 주소를 저장하고 안내하는 역할을 한다.
* 도메인 판매 업체의 DNS 설정이 변경되면 도메인 등록 기관으로 전달된다. 따라서 어떤 도메인이 어떤 판매 업체에서 구입됐는지 알 수 있다.

3. Second-Level Domain(SLD) DNS 서버(Authoritative DNS 서버)
* 실제 개인 도메인과 IP 주소의 관계가 기록(저장, 변경)되는 서버.
* 일반적으로 도메인/호스팅 업체의 네임서버를 말한다

4. 권한 없는 DNS 서버 (리졸버 서버, 리컬시브 서버, 리커서)
* DNS 서버는 도메인 네임 스페이스를 위한 권한 있는 DNS 서버와 권한이 없는 DNS 서버로 구분된다.
* 위 1,2,3은 권한 있는 DNS 서버이다.
* 네임 스페이스를 위한 권한 있는 DNS 서버는 IP 주소와 도메인 이름을 매핑한다.
* 네임 스페이스를 위한 권한 없는 DNS 서버는 질의를 통해 IP 주소를 알아내거나 캐시한다.

### DNS 동작 과정 전체
![img.png](images/ymk/DNS_ymk.png)


---

# TCP 3-way Handshake
>TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에
먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

![img.png](images/ymk/3way_ymk.png)

* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기전에 다른 쪽이 준비되었다는 것을 알수 있도록 한다.

# TCP 4-way Handshake
> 4-Way handshake는 세션을 종료하기 위해 수행되는 절차다.

![img.png](images/ymk/4way_ymk.png)

**_만약 "Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황"이 발생한다면 어떻게 될까?_**

-> Client에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop되고 데이터는 유실될 것이다.

이러한 현상에 대비하여 Client는 Server로부터 FIN을 수신하더라도 일정시간(Default = 2MSL(Maximum Segment Length))동안 세션을 남겨놓고
잉여 패킷을 기다린다. 이러한 과정을 "TIME_WAIT"라고 한다.

### 3 way와 4 way가 단계 차이가 나는 이유?
> Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에 일단 ACK만 먼저 보내고, 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.

---

# HTTP

> **HTTP는 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)이다. 웹 페이지를 방문할 때마다 컴퓨터는 HTTP를 사용하여 인터넷 어딘가에
> 있는 다른 컴퓨터에서 해당 페이지를 다운로드한다.**

### _HTTP 특징_

1. **클라이언트 서버 구조**
  * Request, Response 구조
  * 클라이언트는 서버에 요청을 보내고 응답을 대기한다.
  * 서버는 요청에 대한 결과를 만들고 응답한다.

![img.png](images/ymk/httpstructure_ymk.png)

2. **Connectionless 프로토콜**
  * 클라이언트가 서버에 요청을 했을 때, 그 요청에 맞는 응답을 보낸 후 연결을 끊는 처리방식이다.
  * 연결 유지를 위한 자원을 아껴 서버의 자원을 효율적으로 사용할 수 있다.
  * HTTP 1.1 버전에서 커넥션을 계속 유지하고 요청에 재활용하는 기능이 추가되었다. HTTP 헤더의 connection에 keep-alive, timeout, max 값으로 옵션을 두면
  커넥션을 재활용하게 된다. HTTP 1.1버전에서는 keep-alive가 디폴트 값이다. **_하지만 HTTP/2, HTTP/3에서는 사용 금지된다._**
  * HTTP/2 버전의 멀티플렉싱(Multiplexing) 기능으로 Persistent Conncetion에 대해 더이상 고민할 필요가 없어지게 되었다.

3. **Stateless 프로토콜**
  * 서버가 클라이언트의 상태를 보존하지 않는다.
  * 서버의 확장성이 높다. (스케일 아웃 - 수평 확장 유리)
  * 중간에 서버 장애가 나더라도 다른 서버에 연결하면 되기 때문에 문제없이 작업 가능하다.
  * 상태를 보존하지 않기 때문에 클라이언트가 데이터를 많이 전송해야 하는 단점이 있다.
  * 하지만 로그인 등 상태를 유지해야 하는 경우가 있다. 이때 쿠키와 세션을 사용한다.

### 쿠키와 세션
> **쿠키와 세션의 가장 큰 차이점은 사용자의 정보가 저장되는 위치다. 쿠키는 서버의 자원을 사용하지 않고, 세션은 서버의 자원을 사용한다.**

* **_쿠키_**
  * 쿠키는 클라이언트 로컬에 저장되는 Key-Value 쌍의 작은 데이터 파일이다.
  * 클라이언트가 서버에게 페이지 정보를 요청하면 쿠키를 생성하고 HTTTP 응답 헤더에 쿠키를 포함해서 응답한다. (set-cookie)
  * 클라이언트는 새로운 요청을 할 경우, 이전에 받은 쿠키값을 HTTP 요청 헤더에 포함하여 요청한다.
  * 서버는 쿠키값을 읽어 클라이언트의 상태를 알게 된다.
  * 쿠키는 유실, 도난, 위조 당할 수 있는 단점이 있다. 따라서 중요한 정보를 담으면 안된다.


* **_세션_**
  * 세션은 서버가 클라이언트에 부여한 세션 ID를 통해 기억하게 된다.
  * 이러한 세션도 쿠키를 통해 관리된다.
  * 규모가 커져 서버가 여러 개가 된다면, 트래픽을 여러 대의 서버에 적절히 분산시켜 줘야 한다. 이를 가능하게 해주는 것이 로드 밸런싱(Load Balancing) 이다.

### HTTP 상태 코드
> **상태코드란 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능이다.**

* **1XX (Informational):** 요청이 수신되어 처리중
* **2XX (Successful):** 요청 정상 처리
* **3XX (Redirection):** 요청을 완료하려면 추가 행동이 필요
* **4XX (Client Error):** 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
* **5XX (Server Error):** 서버 오류, 서버가 정상 요청을 처리하지 못함


<br>

#### _**2XX (Successful)**_

- **200 OK:** 서버가 요청을 제대로 처리했다.
- **201 Created:** 성공적으로 요청되었으며 서버가 새 리소스를 작성했다.
- **202 Accepted:** 요청이 접수되었으나 처리가 완료되지 않음.
- **204 No Content:** 서버가 요청을 성공적으로 처리했지만 콘텐츠를 제공하지 않는다.

<br>

#### _**3XX (Redirection)**_

> **_리다이렉션_**
>
> 웹 브라우저는 3XX 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동한다. (Redirect)
> 
> _**종류:**_
> * 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동 -> 301, 308
>   * 예) /members → /users
>   * /event → /new-event
> * 일시 리다이렉션 - 일시적인 변경 -> 302, 303, 307
>   * 주문 완료 후 주문 내역 화면으로 이동
>   * PRG: Post/Redirect/Get
> * 특수 리다이렉션
>   * 결과 대신 캐시를 사용



- **300 Multiple Choices:** 서버가 요청에 따라 여러 조치를 선택할 수 있다. 서버가 사용자 에이전트에 따라 수행할 작업을 선택하거나, 요청자가 선택할 수 있는 작업 목록을 제공한다.
- **301 Moved Permanently:** 요청한 리소스의 URI가 변경되었음을 의미한다. 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음 (MAY)
- **302 Found:** 이 응답 코드는 요청한 리소스의 URI가 일시적으로 변경되었음을 의미한다. 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음 (MAY)
- **303 See Other:** 302와 같은 기능, 리다이렉트시 요청 메서드가 GET으로 변경.
- **304 Not Modified:** 캐시를 목적으로 사용, 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트 한다.). 304 응답은 응답에 메시지 바디를 포함하면 안된다. 
- **307 Temporary Redirect:** 302와 같은 기능, 리다이렉트시 요청 메서드와 본문 유지.
- **308 Permanent Redirect:** 301과 같은 기능, 라다이렉트시 요청 메서드와 본문 유지 (처음 POST를 보내면 리다이렉트도 POST 유지).

<br>

#### _**4XX (Client Error)**_

- **400 Bad Request -** 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음. 클라이언트는 요청 내용을 다시 검토하고 보내야 한다.
- **401 Unauthorized -** 클라이언트가 해당 리소스에 대한 인증이 필요함, 인증(Authentication) 되지 않음.
- **403 Forbidden -** 서버가 요청을 이해했지만 승인을 거부함. 주로 인증 자격 증명은 있지만, 접근 권한이 불충분한 경우다. 
- **404 Not Found -** 요청 리소스를 찾을 수 없음. 요청 리소스가 서버에 없다. 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때 사용된다.

<br>

#### _**5XX (Server Error)**_

- **500 Internal Server Error -** 서버 내부 문제로 오류 발생
- **502 Bad Gateway -** 서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 잘못된 응답을 받았다.
- **503 Service Unavailable -** 서비스 이용 불가. 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음. Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수도 있음.

<br>

### HTTP Method

#### 주요 메서드

- **GET:** 리소스 조회
- **POST:** 요청 데이터 처리, 주로 등록에 사용
- **PUT:** 리소스를 대체, 해당 리소스가 없으면 생성
- **PATCH:** 리소스 부분 변경
- **DELETE:** 리소스 삭제

#### 기타 메서드

- **HEAD:** GET과 동일하지만 메시지 부분을 제외하고, 상태 줄과 헤더만 반환
- **OPTIONS:** 대상 리소스에 대한 통신 옵션 (메서드)을 설명(주로 CORS에서 사용)
- **CONNECT:** 대상 자원으로 식별되는 서버에 대한 터널을 설정
- **TRACE:** 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

#### GET
* 리소스 조회
* 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 퀴리 스트링)을 통해서 전달
* 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많이 없고, RESTful API를 지키도록 위해 사용 X

#### POST
* 요청 데이터 처리
* 메시지 바디를 통해 서버로 요청 데이터 전달
* 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

#### PUT
- 리소스가 있으면 대체
- 리소스가 없으면 생성
- *쉽게 이야기해서 덮어버림*

#### PATCH
- 리소스 부분 변경

### HTTP Method 속성
- **안전(Safe Methods)**
- **멱등(Idempotent Methods)**
- **캐시 가능(Cacheable Methods)**

> #### 안전
> 리소스를 변경하지 않는다.
> * GET 안전
>* POST, PUT, PATCH, DELETE 안전하지 않음

> #### 멱등
> 같은 요청을 계속해도 결과가 같은 것을 멱등이라고 한다.
> - **GET:** 같은 결과가 조회된다.
> - **PUT**: 결과를 대체 한다. 따라서 같은 요청을 여러번 해도 최종 결과는 같다.
> - **DELETE:** 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
> - **POST: 멱등이 아니다! 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.**

> #### 캐시 가능
> - 응답 결과 리소스를 캐시해서 사용해도 되는가?
> - **GET, HEAD, POST, PATCH** 캐시가능
> - 실제로는 **GET, HEAD** 정도만 캐시로 사용
>  - **POST, PATCH**는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음


---

### Reference
https://backendcode.tistory.com/167#article-3--3--%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0

https://velog.io/@jehjong/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0-TCPIP-4%EA%B3%84%EC%B8%B5

https://velog.io/@backtony

https://hanamon.kr/dns%EB%9E%80-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%84%A4%EC%9E%84-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EB%85%90%EB%B6%80%ED%84%B0-%EC%9E%91%EB%8F%99-%EB%B0%A9%EC%8B%9D%EA%B9%8C%EC%A7%80/

https://bangu4.tistory.com/74

https://dev-coco.tistory.com/61