# Database

---

## DBMS

* 데이터베이스 관리 시스템(Database Management System)으로 여러 사용자가 데이터베이스에 접근하여 사용할 수 있도록 해주는 소프트웨어


* DBMS의 유형은 계층형(Hierarchical), 망형(Network), 관계형(Relational), 객체지향형(Object-Oriented), 객체관계형(Object-Relational) 등으로 분류된다.


* 현재 사용되는 DBMS 중에는 관계형 DBMS가 가장 많은 부분을 차지한다.


### DB를 사용하는 이유

* 데이터베이스의 특징인 독립성, 무결성, 보안성, 일관성, 중복 최소화가 있기 때문이다.
* 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해친다.

### 스키마

* 데이터베이스의 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터 집합

### 테이블

* 열과 행으로 구성되어 있으며 특정한 종류의 데이터를 구조적으로 묶은 목록이다.
* 릴레이션이라고도 부른다.

### 행

* 테이블을 구성하는 데이터들 중 가로로 묶은 데이터 셋
* 일반적으로 한 행은 한 객체에 대한 정보를 갖는다.
* 튜플 또는 레코드라고 부른다.

### 열

* 테이블을 구성하는 데이터들 중 세로로 묶은 데이터 셋으로 속성 이라고 부름

### 도메인

* 데이터베이스 필드에 채워질 수 있는 값들의 집합
* 예를 들어, 도메인이 1과 10 사이의 정수인데 11이 들어가거나 "고양이"가 들어갈 수 없음

### 뷰

* 하나 이상의 테이블에서 유도된, 메모리에 물리적으로 존재하지 않는 가상의 테이블이다.
* 특정 사용자로부터 특정 속성을 숨기는 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용한다.
* 인덱스를 가질 수 없고, 뷰의 정의를 변경할 수 없다.
* 기본 키를 포함하고 정의할 경우, 삽입, 삭제, 갱신 가능하다.

## 키

* 슈퍼 키 > 후보 키 > 대체 키 >= 기본 키
* 검색, 정렬 시 튜플을 구분하는 기준이 되는 속성
* 유일성: 키로 튜플을 유일하게 식별할 수 있음
* 최소성: 튜플을 구분하는데 꼭 필요한 속성들로만 구성

### 후보 키

* 테이블을 구성하는 속성 중에서 튜플을 유일하게 식별할 수 있는 속성들의 부분 집합
  * 기본 키로 사용할 수 있는 속성들
* 모든 테이블은 하나 이상의 후보 키를 가짐(기본키)
* 유일성과 최소성 만족

### 기본 키

* 후보 키 중에서 선택한 Primary Key
* 특정 튜플을 유일하게 식별 가능
* 중복값과 NULL 불가
* 유일성과 최소성 만족

### 대체 키

* 후보 키가 두개 이상일 때, 기본 키를 제외한 나머지 후보 키

### 슈퍼 키

* 고유하게 식별하는 모든 후보키의 조합하는 키
* 유일성은 만족하지만, 최소성은 만족하지 않음

### 외래 키

* **다른 릴레이션(테이블)의 속성, 참조 관계를 표현하는데 사용하는 키**
* 테이블의 열 중 다른 테이블의 기본키를 참조하는 열
* 테이블 간의 연결, 중복 방지, 무결성 유지

---

# 트랜잭션

* 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위
* 논리적인 작업의 쿼리 캐수와 관계 없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장 -> 원자성

### 트랜택션 특징 (ACID)

* Atomicity(원자성)
  * 트랜잭션을 구성하는 연산 전체가 모두 정상적으로 실행되거나 모두 취소되어야 한다.
  

* Consistency(일관성)
  * 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지한다.


* Isolation(고립성)
  * 두 개 이상의 트랜잭션이 동시에 발생할 때, 서로의 연산에 영향을 주면 안된다.


* Durability(영구성)
  * 커밋된 트랜잭션의 내용은 영구히 반영된다.


### 트랜잭션 상태

* 활동(Active State)
  * 트랜잭션이 실행 중인 상태


* 장애(Failed State)
  * 트랜잭션이 실행에 오류가 발생하여 중단한 상태


* 철회(Aborted State)
  * 트랜잭션이 비정상적으로 종료되어 Rollback 수행하는 상태


* 부분 완료(Partially Committed)
  * 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전 상태


* 완료(Committed State)
  * 트랜잭션이 성공적으로 종료되어 commit 연산을 실행한 후의 상태

### 트랜잭션 격리수준

> **트랜잭션의 격리 수준(Isolation Level)이란 여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 
> 볼 수 있게 허용할지 여부를 결정하는 것이다.**

1. _**Serializable**_

가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킨다. 여러 트랜잭션이 동일한 테이블에 동시 접근할 수 없으므로, 어떠한 데이터
부정합 문제도 발생하지 않는다. 하지만 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어진다.
Lock이 발생한다.

2. **_Repeatable read_**

커밋이 완료된 데이터만 읽을 수 있으며, 트랜잭션 범위 내에서 조회한 내용이 항상 동일함을 보장한다. 하지만 일정범위의 레코드를 두번 이상 읽을 때,
첫 번재 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상인 Phantom Read가 발생할 수 있다. Mysql은 갭 락을 통해 이를 방지한다.
Lock이 발생한다.

3. **_Read Committed_**

커밋된 데이터만 조회할 수 있다. READ COMMITTED는 REPEATABLE READ에서 발생하는 Phantom Read에 더해
한 트랜잭션 내에서 검색 결과가 비일관적인 Non-Repeatable Read(반복 읽기 불가능) 문제까지 발생한다.
Lock이 발생하지 않는다.

4. **_Read Uncommitted_**

READ UNCOMMITTED는 커밋하지 않은 데이터 조차도 접근할 수 있는 격리 수준이다. 어떤 트랜잭션의 작업이 완료되지 않았는데도, 다른 트랜잭션에서 볼 수 있는 부정합 문제를 Dirty Read(오손 읽기)라고 한다.

### Commit

* 트랜잭션이 성공하여 트랜잭션 결과를 영구적으로 반영하는 연산

### Rollback

* 트랜잭션의 실행을 취소하였음을 알리는 연산
* 트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀시키는 연산

___

### Reference

https://hongong.hanbit.co.kr/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-databasedb-dbms-sql%EC%9D%98-%EA%B0%9C%EB%85%90/

https://velog.io/@backtony/%EB%A9%B4%EC%A0%91-%EC%8B%9C%EB%A6%AC%EC%A6%883-DB#dbms

https://mangkyu.tistory.com/299